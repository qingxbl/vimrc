# C file

snippet once "Include header once only guard" b
#ifndef ${1:`!p
if not snip.c:
	snip.rv = re.sub(r'[^A-Za-z0-9]+','_', snip.fn).lower()
else:
	snip.rv = snip.c`}
#define $1

${VISUAL}${0}

#endif /* $1 */
endsnippet

snippet co "make inline comments" i
/* ${VISUAL}${0} */
endsnippet

snippet c "C frame code" b
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	${VISUAL}${0}
	return 0;
}
endsnippet

# C file with arguments
snippet c2 "C frame code with 2-argument main" b
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
	${VISUAL}${0}
	return 0;
}
endsnippet

snippet main "main function" b
int main(void)
{
	${VISUAL}${0}
	return 0;
}
endsnippet


snippet main2 "main function with arguments" b
int main(int argc, char **argv)
{
	${VISUAL}${0}
	return 0;
}
endsnippet

snippet lua "Lua host C frame code" b
#include <stdio.h>
#include <stdlib.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

int main(void)
{
	lua_State *L = luaL_newstate();
	luaL_openlibs(L);
	${VISUAL}${0}
	lua_close(L);
	return 0;
}
/* cc: flags+='-s -O2 -DLUA_BUILD_AS_DLL' libs+='-llua53' */
endsnippet

snippet luamod "Lua C module frame code" b
#define LUA_LIB
#include <lua.h>
#include <lauxlib.h>

static int L$2(lua_State *L)
{
	return 0;
}

LUALIB_API int luaopen_${1:module}(lua_State *L)
{
	luaL_Reg libs[] = {
#define ENTRY(name) { #name, L##name }
		ENTRY(${2:name}),
#undef  ENTRY
		{ NULL, NULL }
	};
	luaL_newlib(L, libs);${0}
	return 1;
}

/* cc: flags+='-s -O2 -mdll -DLUA_BUILD_AS_DLL'
 * cc: libs+='-llua53' output='$1.dll' */
endsnippet

# luareg
snippet luareg "Lua module registry entries" b
luaL_Reg libs[] = {
#define ENTRY(name) { #name, L##name }
	ENTRY(${1:name}),
#undef  ENTRY
	{ NULL, NULL }
};
endsnippet

# stdwin
snippet stdwin "Standard frame code for Windows" b
#define _WIN32_WINNT 0x0501
#include <Windows.h>

LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;
	HDC hdc;
	switch (uMsg) {
	case WM_PAINT: 
		hdc = BeginPaint(hWnd, &ps);

		TextOut(hdc, 10, 10, TEXT("Hello World!"), -1);

		EndPaint(hWnd, &ps);
		return 0;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	}
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

int CALLBACK WinMain(HINSTANCE hInst, HINSTANCE hPreInst,
	LPSTR strCmdLine, int nCmdShow)
{
	MSG msg;
	HWND hWnd;
	WNDCLASSEX wc = {
		sizeof(wc), CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS,
		WndProc, 0, 0, hInst,
		LoadIcon(NULL, IDI_APPLICATION), LoadCursor(NULL, IDC_ARROW),
		(HBRUSH)GetStockObject(WHITE_BRUSH), NULL, "My Class", NULL
	};

	${VISUAL}${0}
	hWnd = CreateWindowEx(0,
		MAKEINTRESOURCE(RegisterClassEx(&wc)),
		"My Window", WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT, 320, 240,
		NULL, NULL, hInst, NULL);

	if (!IsWindow(hWnd))
		return 1;

	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);

	while (GetMessage(&msg, NULL, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;
}

/* cc: flags+='-mwindows -static' */
endsnippet

